package com.kiran.collection;

import java.util.PriorityQueue;
import java.util.Queue;

public class QueuePratice {

	public static void main(String[] args) {

		/*
		 * Queue = FIFO data structure where elements enter from rear and exit from front.
		 * 
		 * Queue        --- Introduced in Java 1.5 (Collections Framework)
		 * Package      --- java.util
		 * Interfaces   --- Queue, Deque, BlockingQueue, etc.
		 * Generics     --- Supported <Wrapper Class | Objects>
		 *
		 * Concept      --- Follows FIFO (First In, First Out)
		 *                  Elements added at the rear (offer)
		 *                  Elements removed from the front (poll)
		 *
		 * Size         --- Number of elements currently stored
		 * Capacity     --- Depends on implementation
		 *                  (LinkedList → No fixed capacity, ArrayDeque → Dynamic capacity)
		 *
		 *
		 * Allow Duplicates                  --- Yes (Most implementations)
		 * Allow null values                 --- No (Queue generally disallows null — optional)
		 * Maintain the insertion order      --- Yes (FIFO)
		 * Maintain the sorted order         --- Only in PriorityQueue
		 * Offer random access               --- No (Traversal required)
		 * Synchronized                      --- No (Except ConcurrentLinkedQueue, BlockingQueue)
		 * Thread Safe                       --- Not by default
		 *
		 *
		 * Common Implementations:
		 * ---------------------------------
		 * LinkedList       --- FIFO Queue (non-synchronized)
		 * ArrayDeque       --- Fast Queue/Deque (recommended)
		 * PriorityQueue    --- Sorted Queue (min-heap)
		 * ConcurrentLinkedQueue --- Thread-safe non-blocking queue
		 * BlockingQueue    --- Thread-safe + waits if full/empty (Producer-Consumer)
		 *
		 *
		 * What is it good at?               --- Scheduling tasks,
		 *                                      Processing requests in order,
		 *                                      BFS algorithms,
		 *                                      Producer-Consumer problems,
		 *                                      Buffering (I/O, networking),
		 *                                      Message queues.
		 *
		 * Important Queue Methods:
		 * ---------------------------------
		 * offer()   --- Insert element (no exception)
		 * add()     --- Insert element (throws exception on failure)
		 * poll()    --- Remove and return front element (no exception)
		 * remove()  --- Remove and return front element (throws exception)
		 * peek()    --- View front element (no exception)
		 * element() --- View front element (throws exception)
		 *
		 *
		 * Limitations                        --- No random access,
		 *                                      Some queues do not allow null,
		 *                                      PriorityQueue does NOT maintain insertion order.
		 */
		
		// Creation of a PriorityQueue
		Queue<String> pqc1 = new PriorityQueue<>();
		
		/*
		 * PriorityQueue --- Introduced in Java 1.5 (Collections Framework)
		 * Package       --- java.util
		 * Generics      --- Supported <Wrapper Class | Objects>
		 *
		 * Concept       --- A Queue where elements are ordered by PRIORITY
		 *                   (Not FIFO)
		 *                   By default → MIN-HEAP (smallest element first)
		 *
		 * Size          --- Number of elements currently stored
		 * Capacity      --- Grows automatically (Default = 11)
		 *                   PriorityQueue<Integer> pq = new PriorityQueue<>(20);
		 *
		 * Default Capacity                  --- 
		 * Initial Capacity                  --- 
		 * Allow Duplicates                  --- Yes
		 * Allow null values                 --- No (Null not allowed)
		 * Maintain insertion order          --- No
		 * Maintain sorted order             --- Internally yes (Heap), but not for iteration
		 * Random Access                     --- No
		 * Synchronized                      --- No
		 * Thread Safe                       --- No (Use PriorityBlockingQueue for thread-safety)
		 *
		 *
		 * Internal Structure                --- Binary Heap (Min-Heap by default)
		 *
		 *
		 * What is it good at?               --- Scheduling tasks,
		 *                                      Handling highest/lowest priority items,
		 *                                      Dijkstra’s algorithm,
		 *                                      CPU scheduling,
		 *                                      Real-time task processing.
		 *
		 *
		 * Important PriorityQueue Methods:
		 * ---------------------------------
		 * offer(element)       --- Insert element
		 * add(element)         --- Insert (throws exception if fails)
		 * peek()               --- View highest-priority element
		 * poll()               --- Remove and return highest-priority element
		 * remove()             --- Remove and return (throws exception)
		 * comparator()         --- Returns custom comparator (if provided)
		 *
		 *
		 * Custom Priority Example:
		 * ---------------------------------
		 * PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
		 * (Now it works as Max-Heap)
		 *
		 *
		 * Limitations                        --- Does NOT maintain full sorted order,
		 *                                      No null allowed,
		 *                                      No random access,
		 *                                      Iteration order is unpredictable.
		 */
		
		// Addition of elements into the list
		pqc1.add("Rattaiah");
		pqc1.offer("Manikyam");
		pqc1.offer("Kiran");
		pqc1.offer("Vamsi");
		pqc1.offer("Akash");
		
		System.out.println(pqc1);
		
		
		System.out.println("\n");
		// Retrival of elements from the list
		System.out.println(pqc1.peek());
		
		System.out.println(pqc1);
		
		System.out.println("\n");
		// Deletion of elements from the list
		System.out.println(pqc1.poll());
		System.out.println(pqc1.remove("Kiran"));
		
		System.out.println(pqc1);
		
		
		System.out.println("\n");
		// Verification of elements in the list
		System.out.println(pqc1.contains("Kiran"));
		
		System.out.println(pqc1);
		pqc1.offer("Akash");
		
		System.out.println("\n");
		// for each iteration --- Don't Use
		for (String str : pqc1) {
			System.out.println(str);
		}
		
		
		System.out.println("\n");
		// While iteration --- Use
		while(!pqc1.isEmpty()) {
			System.out.println(pqc1.poll());
		}

	}

}
